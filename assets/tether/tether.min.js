!(function (t, e) { typeof define === 'function' && define.amd ? define(e) : typeof exports === 'object' ? module.exports = e(require, exports, module) : t.Tether = e() }(this, function (t, e, o) { 'use strict'; function i (t, e) { if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function') } function n (t) { const e = getComputedStyle(t); const o = e.position; if (o === 'fixed') return t; for (let i = t; i = i.parentNode;) { let n = void 0; try { n = getComputedStyle(i) } catch (r) {} if (typeof n === 'undefined' || n === null) return i; const s = n; const a = s.overflow; const f = s.overflowX; const h = s.overflowY; if (/(auto|scroll)/.test(a + h + f) && (o !== 'absolute' || ['relative', 'absolute', 'fixed'].indexOf(n.position) >= 0)) return i } return document.body } function r (t) { let e = void 0; t === document ? (e = document, t = document.documentElement) : e = t.ownerDocument; const o = e.documentElement; const i = {}; const n = t.getBoundingClientRect(); for (const r in n)i[r] = n[r]; const s = x(e); return i.top -= s.top, i.left -= s.left, typeof i.width === 'undefined' && (i.width = document.body.scrollWidth - i.left - i.right), typeof i.height === 'undefined' && (i.height = document.body.scrollHeight - i.top - i.bottom), i.top = i.top - o.clientTop, i.left = i.left - o.clientLeft, i.right = e.body.clientWidth - i.width - i.left, i.bottom = e.body.clientHeight - i.height - i.top, i } function s (t) { return t.offsetParent || document.documentElement } function a () { const t = document.createElement('div'); t.style.width = '100%', t.style.height = '200px'; const e = document.createElement('div'); f(e.style, { position: 'absolute', top: 0, left: 0, pointerEvents: 'none', visibility: 'hidden', width: '200px', height: '150px', overflow: 'hidden' }), e.appendChild(t), document.body.appendChild(e); const o = t.offsetWidth; e.style.overflow = 'scroll'; let i = t.offsetWidth; o === i && (i = e.clientWidth), document.body.removeChild(e); const n = o - i; return { width: n, height: n } } function f () { const t = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0]; const e = []; return Array.prototype.push.apply(e, arguments), e.slice(1).forEach(function (e) { if (e) for (const o in e)({}).hasOwnProperty.call(e, o) && (t[o] = e[o]) }), t } function h (t, e) { if (typeof t.classList !== 'undefined')e.split(' ').forEach(function (e) { e.trim() && t.classList.remove(e) }); else { const o = new RegExp('(^| )' + e.split(' ').join('|') + '( |$)', 'gi'); const i = u(t).replace(o, ' '); p(t, i) } } function l (t, e) { if (typeof t.classList !== 'undefined')e.split(' ').forEach(function (e) { e.trim() && t.classList.add(e) }); else { h(t, e); const o = u(t) + (' ' + e); p(t, o) } } function d (t, e) { if (typeof t.classList !== 'undefined') return t.classList.contains(e); const o = u(t); return new RegExp('(^| )' + e + '( |$)', 'gi').test(o) } function u (t) { return t.className instanceof SVGAnimatedString ? t.className.baseVal : t.className } function p (t, e) { t.setAttribute('class', e) } function c (t, e, o) { o.forEach(function (o) { e.indexOf(o) === -1 && d(t, o) && h(t, o) }), e.forEach(function (e) { d(t, e) || l(t, e) }) } function i (t, e) { if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function') } function g (t, e) { const o = arguments.length <= 2 || void 0 === arguments[2] ? 1 : arguments[2]; return t + o >= e && e >= t - o } function m () { return typeof performance !== 'undefined' && typeof performance.now !== 'undefined' ? performance.now() : +new Date() } function v () { for (var t = { top: 0, left: 0 }, e = arguments.length, o = Array(e), i = 0; e > i; i++)o[i] = arguments[i]; return o.forEach(function (e) { let o = e.top; let i = e.left; typeof o === 'string' && (o = parseFloat(o, 10)), typeof i === 'string' && (i = parseFloat(i, 10)), t.top += o, t.left += i }), t } function y (t, e) { return typeof t.left === 'string' && t.left.indexOf('%') !== -1 && (t.left = parseFloat(t.left, 10) / 100 * e.width), typeof t.top === 'string' && t.top.indexOf('%') !== -1 && (t.top = parseFloat(t.top, 10) / 100 * e.height), t } function b (t, e) { return e === 'scrollParent' ? e = t.scrollParent : e === 'window' && (e = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset]), e === document && (e = e.documentElement), typeof e.nodeType !== 'undefined' && !(function () { const t = r(e); const o = t; const i = getComputedStyle(e); e = [o.left, o.top, t.width + o.left, t.height + o.top], U.forEach(function (t, o) { t = t[0].toUpperCase() + t.substr(1), t === 'Top' || t === 'Left' ? e[o] += parseFloat(i['border' + t + 'Width']) : e[o] -= parseFloat(i['border' + t + 'Width']) }) }()), e } var w = (function () { function t (t, e) { for (let o = 0; o < e.length; o++) { const i = e[o]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, o, i) { return o && t(e.prototype, o), i && t(e, i), e } }()); let C = void 0; typeof C === 'undefined' && (C = { modules: [] }); const O = (function () { let t = 0; return function () { return ++t } }()); const E = {}; var x = function (t) { let e = t._tetherZeroElement; typeof e === 'undefined' && (e = t.createElement('div'), e.setAttribute('data-tether-id', O()), f(e.style, { top: 0, left: 0, position: 'absolute' }), t.body.appendChild(e), t._tetherZeroElement = e); const o = e.getAttribute('data-tether-id'); if (typeof E[o] === 'undefined') { E[o] = {}; const i = e.getBoundingClientRect(); for (const n in i)E[o][n] = i[n]; T(function () { delete E[o] }) } return E[o] }; const A = []; var T = function (t) { A.push(t) }; var S = function () { for (let t = void 0; t = A.pop();)t() }; const W = (function () { function t () { i(this, t) } return w(t, [{ key: 'on', value: function (t, e, o) { const i = arguments.length <= 3 || void 0 === arguments[3] ? !1 : arguments[3]; typeof this.bindings === 'undefined' && (this.bindings = {}), typeof this.bindings[t] === 'undefined' && (this.bindings[t] = []), this.bindings[t].push({ handler: e, ctx: o, once: i }) } }, { key: 'once', value: function (t, e, o) { this.on(t, e, o, !0) } }, { key: 'off', value: function (t, e) { if (typeof this.bindings === 'undefined' || typeof this.bindings[t] === 'undefined') if (typeof e === 'undefined') delete this.bindings[t]; else for (let o = 0; o < this.bindings[t].length;) this.bindings[t][o].handler === e ? this.bindings[t].splice(o, 1) : ++o } }, { key: 'trigger', value: function (t) { if (typeof this.bindings !== 'undefined' && this.bindings[t]) { for (var e = 0, o = arguments.length, i = Array(o > 1 ? o - 1 : 0), n = 1; o > n; n++)i[n - 1] = arguments[n]; for (;e < this.bindings[t].length;) { const r = this.bindings[t][e]; const s = r.handler; const a = r.ctx; const f = r.once; let h = a; typeof h === 'undefined' && (h = this), s.apply(h, i), f ? this.bindings[t].splice(e, 1) : ++e } } } }]), t }()); C.Utils = { getScrollParent: n, getBounds: r, getOffsetParent: s, extend: f, addClass: l, removeClass: h, hasClass: d, updateClasses: c, defer: T, flush: S, uniqueId: O, Evented: W, getScrollBarSize: a }; var M = (function () { function t (t, e) { const o = []; let i = !0; let n = !1; let r = void 0; try { for (var s, a = t[Symbol.iterator](); !(i = (s = a.next()).done) && (o.push(s.value), !e || o.length !== e); i = !0); } catch (f) { n = !0, r = f } finally { try { !i && a.return && a.return() } finally { if (n) throw r } } return o } return function (e, o) { if (Array.isArray(e)) return e; if (Symbol.iterator in Object(e)) return t(e, o); throw new TypeError('Invalid attempt to destructure non-iterable instance') } }()); var w = (function () { function t (t, e) { for (let o = 0; o < e.length; o++) { const i = e[o]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, o, i) { return o && t(e.prototype, o), i && t(e, i), e } }()); if (typeof C === 'undefined') throw new Error('You must include the utils.js file before tether.js'); var P = C.Utils; var n = P.getScrollParent; var r = P.getBounds; var s = P.getOffsetParent; var f = P.extend; var l = P.addClass; var h = P.removeClass; var c = P.updateClasses; var T = P.defer; var S = P.flush; var a = P.getScrollBarSize; const k = (function () { if (typeof document === 'undefined') return ''; for (let t = document.createElement('div'), e = ['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform'], o = 0; o < e.length; ++o) { const i = e[o]; if (void 0 !== t.style[i]) return i } }()); const B = []; const _ = function () { B.forEach(function (t) { t.position(!1) }), S() }; !(function () { let t = null; let e = null; let o = null; const i = function n () { return typeof e !== 'undefined' && e > 16 ? (e = Math.min(e - 16, 250), void (o = setTimeout(n, 250))) : void (typeof t !== 'undefined' && m() - t < 10 || (typeof o !== 'undefined' && (clearTimeout(o), o = null), t = m(), _(), e = m() - t)) }; typeof window !== 'undefined' && ['resize', 'scroll', 'touchmove'].forEach(function (t) { window.addEventListener(t, i) }) }()); const z = { center: 'center', left: 'right', right: 'left' }; const F = { middle: 'middle', top: 'bottom', bottom: 'top' }; const L = { top: 0, left: 0, middle: '50%', center: '50%', bottom: '100%', right: '100%' }; const Y = function (t, e) { let o = t.left; let i = t.top; return o === 'auto' && (o = z[e.left]), i === 'auto' && (i = F[e.top]), { left: o, top: i } }; const H = function (t) { let e = t.left; let o = t.top; return typeof L[t.left] !== 'undefined' && (e = L[t.left]), typeof L[t.top] !== 'undefined' && (o = L[t.top]), { left: e, top: o } }; const X = function (t) { const e = t.split(' '); const o = M(e, 2); const i = o[0]; const n = o[1]; return { top: i, left: n } }; const j = X; const N = (function () { function t (e) { const o = this; i(this, t), this.position = this.position.bind(this), B.push(this), this.history = [], this.setOptions(e, !1), C.modules.forEach(function (t) { typeof t.initialize !== 'undefined' && t.initialize.call(o) }), this.position() } return w(t, [{ key: 'getClass', value: function () { const t = arguments.length <= 0 || void 0 === arguments[0] ? '' : arguments[0]; const e = this.options.classes; return typeof e !== 'undefined' && e[t] ? this.options.classes[t] : this.options.classPrefix ? this.options.classPrefix + '-' + t : t } }, { key: 'setOptions', value: function (t) { const e = this; const o = arguments.length <= 1 || void 0 === arguments[1] ? !0 : arguments[1]; const i = { offset: '0 0', targetOffset: '0 0', targetAttachment: 'auto auto', classPrefix: 'tether' }; this.options = f(i, t); const r = this.options; const s = r.element; const a = r.target; const h = r.targetModifier; if (this.element = s, this.target = a, this.targetModifier = h, this.target === 'viewport' ? (this.target = document.body, this.targetModifier = 'visible') : this.target === 'scroll-handle' && (this.target = document.body, this.targetModifier = 'scroll-handle'), ['element', 'target'].forEach(function (t) { if (typeof e[t] === 'undefined') throw new Error('Tether Error: Both element and target must be defined'); typeof e[t].jquery !== 'undefined' ? e[t] = e[t][0] : typeof e[t] === 'string' && (e[t] = document.querySelector(e[t])) }), l(this.element, this.getClass('element')), this.options.addTargetClasses !== !1 && l(this.target, this.getClass('target')), !this.options.attachment) throw new Error('Tether Error: You must provide an attachment'); this.targetAttachment = j(this.options.targetAttachment), this.attachment = j(this.options.attachment), this.offset = X(this.options.offset), this.targetOffset = X(this.options.targetOffset), typeof this.scrollParent !== 'undefined' && this.disable(), this.targetModifier === 'scroll-handle' ? this.scrollParent = this.target : this.scrollParent = n(this.target), this.options.enabled !== !1 && this.enable(o) } }, { key: 'getTargetBounds', value: function () { if (typeof this.targetModifier === 'undefined') return r(this.target); if (this.targetModifier === 'visible') { if (this.target === document.body) return { top: pageYOffset, left: pageXOffset, height: innerHeight, width: innerWidth }; var t = r(this.target); var e = { height: t.height, width: t.width, top: t.top, left: t.left }; return e.height = Math.min(e.height, t.height - (pageYOffset - t.top)), e.height = Math.min(e.height, t.height - (t.top + t.height - (pageYOffset + innerHeight))), e.height = Math.min(innerHeight, e.height), e.height -= 2, e.width = Math.min(e.width, t.width - (pageXOffset - t.left)), e.width = Math.min(e.width, t.width - (t.left + t.width - (pageXOffset + innerWidth))), e.width = Math.min(innerWidth, e.width), e.width -= 2, e.top < pageYOffset && (e.top = pageYOffset), e.left < pageXOffset && (e.left = pageXOffset), e } if (this.targetModifier === 'scroll-handle') { var t = void 0; let o = this.target; o === document.body ? (o = document.documentElement, t = { left: pageXOffset, top: pageYOffset, height: innerHeight, width: innerWidth }) : t = r(o); const i = getComputedStyle(o); const n = o.scrollWidth > o.clientWidth || [i.overflow, i.overflowX].indexOf('scroll') >= 0 || this.target !== document.body; let s = 0; n && (s = 15); const a = t.height - parseFloat(i.borderTopWidth) - parseFloat(i.borderBottomWidth) - s; var e = { width: 15, height: 0.975 * a * (a / o.scrollHeight), left: t.left + t.width - parseFloat(i.borderLeftWidth) - 15 }; let f = 0; a < 408 && this.target === document.body && (f = -11e-5 * Math.pow(a, 2) - 0.00727 * a + 22.58), this.target !== document.body && (e.height = Math.max(e.height, 24)); const h = this.target.scrollTop / (o.scrollHeight - a); return e.top = h * (a - e.height - f) + t.top + parseFloat(i.borderTopWidth), this.target === document.body && (e.height = Math.max(e.height, 24)), e } } }, { key: 'clearCache', value: function () { this._cache = {} } }, { key: 'cache', value: function (t, e) { return typeof this._cache === 'undefined' && (this._cache = {}), typeof this._cache[t] === 'undefined' && (this._cache[t] = e.call(this)), this._cache[t] } }, { key: 'enable', value: function () { const t = arguments.length <= 0 || void 0 === arguments[0] ? !0 : arguments[0]; this.options.addTargetClasses !== !1 && l(this.target, this.getClass('enabled')), l(this.element, this.getClass('enabled')), this.enabled = !0, this.scrollParent !== document && this.scrollParent.addEventListener('scroll', this.position), t && this.position() } }, { key: 'disable', value: function () { h(this.target, this.getClass('enabled')), h(this.element, this.getClass('enabled')), this.enabled = !1, typeof this.scrollParent !== 'undefined' && this.scrollParent.removeEventListener('scroll', this.position) } }, { key: 'destroy', value: function () { const t = this; this.disable(), B.forEach(function (e, o) { return e === t ? void B.splice(o, 1) : void 0 }) } }, { key: 'updateAttachClasses', value: function (t, e) { const o = this; t = t || this.attachment, e = e || this.targetAttachment; const i = ['left', 'top', 'bottom', 'right', 'middle', 'center']; typeof this._addAttachClasses !== 'undefined' && this._addAttachClasses.length && this._addAttachClasses.splice(0, this._addAttachClasses.length), typeof this._addAttachClasses === 'undefined' && (this._addAttachClasses = []); const n = this._addAttachClasses; t.top && n.push(this.getClass('element-attached') + '-' + t.top), t.left && n.push(this.getClass('element-attached') + '-' + t.left), e.top && n.push(this.getClass('target-attached') + '-' + e.top), e.left && n.push(this.getClass('target-attached') + '-' + e.left); const r = []; i.forEach(function (t) { r.push(o.getClass('element-attached') + '-' + t), r.push(o.getClass('target-attached') + '-' + t) }), T(function () { typeof o._addAttachClasses !== 'undefined' && (c(o.element, o._addAttachClasses, r), o.options.addTargetClasses !== !1 && c(o.target, o._addAttachClasses, r), delete o._addAttachClasses) }) } }, { key: 'position', value: function () { const t = this; const e = arguments.length <= 0 || void 0 === arguments[0] ? !0 : arguments[0]; if (this.enabled) { this.clearCache(); const o = Y(this.targetAttachment, this.attachment); this.updateAttachClasses(this.attachment, o); const i = this.cache('element-bounds', function () { return r(t.element) }); let n = i.width; let f = i.height; if (n === 0 && f === 0 && typeof this.lastSize !== 'undefined') { const h = this.lastSize; n = h.width, f = h.height } else this.lastSize = { width: n, height: f }; const l = this.cache('target-bounds', function () { return t.getTargetBounds() }); const d = l; let u = y(H(this.attachment), { width: n, height: f }); let p = y(H(o), d); const c = y(this.offset, { width: n, height: f }); const g = y(this.targetOffset, d); u = v(u, c), p = v(p, g); for (var m = l.left + p.left - u.left, b = l.top + p.top - u.top, w = 0; w < C.modules.length; ++w) { const O = C.modules[w]; const E = O.position.call(this, { left: m, top: b, targetAttachment: o, targetPos: l, elementPos: i, offset: u, targetOffset: p, manualOffset: c, manualTargetOffset: g, scrollbarSize: A, attachment: this.attachment }); if (E === !1) return !1; typeof E !== 'undefined' && typeof E === 'object' && (b = E.top, m = E.left) } const x = { page: { top: b, left: m }, viewport: { top: b - pageYOffset, bottom: pageYOffset - b - f + innerHeight, left: m - pageXOffset, right: pageXOffset - m - n + innerWidth } }; var A = void 0; return document.body.scrollWidth > window.innerWidth && (A = this.cache('scrollbar-size', a), x.viewport.bottom -= A.height), document.body.scrollHeight > window.innerHeight && (A = this.cache('scrollbar-size', a), x.viewport.right -= A.width), (['', 'static'].indexOf(document.body.style.position) === -1 || ['', 'static'].indexOf(document.body.parentElement.style.position) === -1) && (x.page.bottom = document.body.scrollHeight - b - f, x.page.right = document.body.scrollWidth - m - n), typeof this.options.optimizations !== 'undefined' && this.options.optimizations.moveElement !== !1 && typeof this.targetModifier === 'undefined' && !(function () { const e = t.cache('target-offsetparent', function () { return s(t.target) }); const o = t.cache('target-offsetparent-bounds', function () { return r(e) }); const i = getComputedStyle(e); const n = o; const a = {}; if (['Top', 'Left', 'Bottom', 'Right'].forEach(function (t) { a[t.toLowerCase()] = parseFloat(i['border' + t + 'Width']) }), o.right = document.body.scrollWidth - o.left - n.width + a.right, o.bottom = document.body.scrollHeight - o.top - n.height + a.bottom, x.page.top >= o.top + a.top && x.page.bottom >= o.bottom && x.page.left >= o.left + a.left && x.page.right >= o.right) { const f = e.scrollTop; const h = e.scrollLeft; x.offset = { top: x.page.top - o.top + f - a.top, left: x.page.left - o.left + h - a.left } } }()), this.move(x), this.history.unshift(x), this.history.length > 3 && this.history.pop(), e && S(), !0 } } }, { key: 'move', value: function (t) { const e = this; if (typeof this.element.parentNode !== 'undefined') { const o = {}; for (const i in t) { o[i] = {}; for (var n in t[i]) { for (var r = !1, a = 0; a < this.history.length; ++a) { const h = this.history[a]; if (typeof h[i] !== 'undefined' && !g(h[i][n], t[i][n])) { r = !0; break } }r || (o[i][n] = !0) } } const l = { top: '', left: '', right: '', bottom: '' }; const d = function (t, o) { const i = typeof e.options.optimizations !== 'undefined'; const n = i ? e.options.optimizations.gpu : null; if (n !== !1) { let r = void 0; let s = void 0; t.top ? (l.top = 0, r = o.top) : (l.bottom = 0, r = -o.bottom), t.left ? (l.left = 0, s = o.left) : (l.right = 0, s = -o.right), l[k] = 'translateX(' + Math.round(s) + 'px) translateY(' + Math.round(r) + 'px)', k !== 'msTransform' && (l[k] += ' translateZ(0)') } else t.top ? l.top = o.top + 'px' : l.bottom = o.bottom + 'px', t.left ? l.left = o.left + 'px' : l.right = o.right + 'px' }; let u = !1; if ((o.page.top || o.page.bottom) && (o.page.left || o.page.right) ? (l.position = 'absolute', d(o.page, t.page)) : (o.viewport.top || o.viewport.bottom) && (o.viewport.left || o.viewport.right) ? (l.position = 'fixed', d(o.viewport, t.viewport)) : typeof o.offset !== 'undefined' && o.offset.top && o.offset.left ? !(function () { l.position = 'absolute'; const i = e.cache('target-offsetparent', function () { return s(e.target) }); s(e.element) !== i && T(function () { e.element.parentNode.removeChild(e.element), i.appendChild(e.element) }), d(o.offset, t.offset), u = !0 }()) : (l.position = 'absolute', d({ top: !0, left: !0 }, t.page)), !u) { for (var p = !0, c = this.element.parentNode; c && c.tagName !== 'BODY';) { if (getComputedStyle(c).position !== 'static') { p = !1; break }c = c.parentNode }p || (this.element.parentNode.removeChild(this.element), document.body.appendChild(this.element)) } const m = {}; let v = !1; for (var n in l) { let y = l[n]; let b = this.element.style[n]; b !== '' && y !== '' && ['top', 'left', 'bottom', 'right'].indexOf(n) >= 0 && (b = parseFloat(b), y = parseFloat(y)), b !== y && (v = !0, m[n] = y) }v && T(function () { f(e.element.style, m) }) } } }]), t }()); N.modules = [], C.position = _; const R = f(N, C); var M = (function () { function t (t, e) { const o = []; let i = !0; let n = !1; let r = void 0; try { for (var s, a = t[Symbol.iterator](); !(i = (s = a.next()).done) && (o.push(s.value), !e || o.length !== e); i = !0); } catch (f) { n = !0, r = f } finally { try { !i && a.return && a.return() } finally { if (n) throw r } } return o } return function (e, o) { if (Array.isArray(e)) return e; if (Symbol.iterator in Object(e)) return t(e, o); throw new TypeError('Invalid attempt to destructure non-iterable instance') } }()); var P = C.Utils; var r = P.getBounds; var f = P.extend; var c = P.updateClasses; var T = P.defer; var U = ['left', 'top', 'right', 'bottom']; C.modules.push({ position: function (t) { const e = this; let o = t.top; let i = t.left; const n = t.targetAttachment; if (!this.options.constraints) return !0; const s = this.cache('element-bounds', function () { return r(e.element) }); let a = s.height; let h = s.width; if (h === 0 && a === 0 && typeof this.lastSize !== 'undefined') { const l = this.lastSize; h = l.width, a = l.height } const d = this.cache('target-bounds', function () { return e.getTargetBounds() }); const u = d.height; const p = d.width; const g = [this.getClass('pinned'), this.getClass('out-of-bounds')]; this.options.constraints.forEach(function (t) { const e = t.outOfBoundsClass; const o = t.pinnedClass; e && g.push(e), o && g.push(o) }), g.forEach(function (t) { ['left', 'top', 'right', 'bottom'].forEach(function (e) { g.push(t + '-' + e) }) }); const m = []; const v = f({}, n); const y = f({}, this.attachment); return this.options.constraints.forEach(function (t) { const r = t.to; let s = t.attachment; let f = t.pin; typeof s === 'undefined' && (s = ''); let l = void 0; let d = void 0; if (s.indexOf(' ') >= 0) { const c = s.split(' '); const g = M(c, 2); d = g[0], l = g[1] } else l = d = s; const w = b(e, r); (d === 'target' || d === 'both') && (o < w[1] && v.top === 'top' && (o += u, v.top = 'bottom'), o + a > w[3] && v.top === 'bottom' && (o -= u, v.top = 'top')), d === 'together' && (o < w[1] && v.top === 'top' && (y.top === 'bottom' ? (o += u, v.top = 'bottom', o += a, y.top = 'top') : y.top === 'top' && (o += u, v.top = 'bottom', o -= a, y.top = 'bottom')), o + a > w[3] && v.top === 'bottom' && (y.top === 'top' ? (o -= u, v.top = 'top', o -= a, y.top = 'bottom') : y.top === 'bottom' && (o -= u, v.top = 'top', o += a, y.top = 'top')), v.top === 'middle' && (o + a > w[3] && y.top === 'top' ? (o -= a, y.top = 'bottom') : o < w[1] && y.top === 'bottom' && (o += a, y.top = 'top'))), (l === 'target' || l === 'both') && (i < w[0] && v.left === 'left' && (i += p, v.left = 'right'), i + h > w[2] && v.left === 'right' && (i -= p, v.left = 'left')), l === 'together' && (i < w[0] && v.left === 'left' ? y.left === 'right' ? (i += p, v.left = 'right', i += h, y.left = 'left') : y.left === 'left' && (i += p, v.left = 'right', i -= h, y.left = 'right') : i + h > w[2] && v.left === 'right' ? y.left === 'left' ? (i -= p, v.left = 'left', i -= h, y.left = 'right') : y.left === 'right' && (i -= p, v.left = 'left', i += h, y.left = 'left') : v.left === 'center' && (i + h > w[2] && y.left === 'left' ? (i -= h, y.left = 'right') : i < w[0] && y.left === 'right' && (i += h, y.left = 'left'))), (d === 'element' || d === 'both') && (o < w[1] && y.top === 'bottom' && (o += a, y.top = 'top'), o + a > w[3] && y.top === 'top' && (o -= a, y.top = 'bottom')), (l === 'element' || l === 'both') && (i < w[0] && y.left === 'right' && (i += h, y.left = 'left'), i + h > w[2] && y.left === 'left' && (i -= h, y.left = 'right')), typeof f === 'string' ? f = f.split(',').map(function (t) { return t.trim() }) : f === !0 && (f = ['top', 'left', 'right', 'bottom']), f = f || []; const C = []; const O = []; o < w[1] && (f.indexOf('top') >= 0 ? (o = w[1], C.push('top')) : O.push('top')), o + a > w[3] && (f.indexOf('bottom') >= 0 ? (o = w[3] - a, C.push('bottom')) : O.push('bottom')), i < w[0] && (f.indexOf('left') >= 0 ? (i = w[0], C.push('left')) : O.push('left')), i + h > w[2] && (f.indexOf('right') >= 0 ? (i = w[2] - h, C.push('right')) : O.push('right')), C.length && !(function () { let t = void 0; t = typeof e.options.pinnedClass !== 'undefined' ? e.options.pinnedClass : e.getClass('pinned'), m.push(t), C.forEach(function (e) { m.push(t + '-' + e) }) }()), O.length && !(function () { let t = void 0; t = typeof e.options.outOfBoundsClass !== 'undefined' ? e.options.outOfBoundsClass : e.getClass('out-of-bounds'), m.push(t), O.forEach(function (e) { m.push(t + '-' + e) }) }()), (C.indexOf('left') >= 0 || C.indexOf('right') >= 0) && (y.left = v.left = !1), (C.indexOf('top') >= 0 || C.indexOf('bottom') >= 0) && (y.top = v.top = !1), (v.top !== n.top || v.left !== n.left || y.top !== e.attachment.top || y.left !== e.attachment.left) && e.updateAttachClasses(y, v) }), T(function () { e.options.addTargetClasses !== !1 && c(e.target, m, g), c(e.element, m, g) }), { top: o, left: i } } }); var P = C.Utils; var r = P.getBounds; var c = P.updateClasses; var T = P.defer; C.modules.push({ position: function (t) { const e = this; const o = t.top; const i = t.left; const n = this.cache('element-bounds', function () { return r(e.element) }); const s = n.height; const a = n.width; const f = this.getTargetBounds(); const h = o + s; const l = i + a; const d = []; o <= f.bottom && h >= f.top && ['left', 'right'].forEach(function (t) { const e = f[t]; (e === i || e === l) && d.push(t) }), i <= f.right && l >= f.left && ['top', 'bottom'].forEach(function (t) { const e = f[t]; (e === o || e === h) && d.push(t) }); const u = []; const p = []; const g = ['left', 'top', 'right', 'bottom']; return u.push(this.getClass('abutted')), g.forEach(function (t) { u.push(e.getClass('abutted') + '-' + t) }), d.length && p.push(this.getClass('abutted')), d.forEach(function (t) { p.push(e.getClass('abutted') + '-' + t) }), T(function () { e.options.addTargetClasses !== !1 && c(e.target, p, u), c(e.element, p, u) }), !0 } }); var M = (function () { function t (t, e) { const o = []; let i = !0; let n = !1; let r = void 0; try { for (var s, a = t[Symbol.iterator](); !(i = (s = a.next()).done) && (o.push(s.value), !e || o.length !== e); i = !0); } catch (f) { n = !0, r = f } finally { try { !i && a.return && a.return() } finally { if (n) throw r } } return o } return function (e, o) { if (Array.isArray(e)) return e; if (Symbol.iterator in Object(e)) return t(e, o); throw new TypeError('Invalid attempt to destructure non-iterable instance') } }()); return C.modules.push({ position: function (t) { let e = t.top; let o = t.left; if (this.options.shift) { let i = this.options.shift; typeof this.options.shift === 'function' && (i = this.options.shift.call(this, { top: e, left: o })); let n = void 0; let r = void 0; if (typeof i === 'string') { i = i.split(' '), i[1] = i[1] || i[0]; const s = i; const a = M(s, 2); n = a[0], r = a[1], n = parseFloat(n, 10), r = parseFloat(r, 10) } else n = i.top, r = i.left; return e += n, o += r, { top: e, left: o } } } }), R }))
